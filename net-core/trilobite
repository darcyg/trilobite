#!/usr/bin/python


from optparse import OptionParser
parser = OptionParser(usage='%prog [options]')
parser.add_option('-n', '--no-revert', action='store_true', dest='no_revert', help='do not schedule tables revert (in case of ssh lock), not recommended, since you never know when firewall may lock itself up')
(optz, argz) = parser.parse_args()


from string import whitespace as spaces
from subprocess import Popen, PIPE
import os, sys, yaml, re


extents = {
	'--mac-source':  '-m mac',
	'--state':  '-m state'
}
extents = [(re.compile('('+k+')'), '%s %s'%(v,k)) for k,v in extents.iteritems()]
pex = re.compile('(?<=-p\s)((\w+/)+\w+)')
vmark = re.compile('(\s*-(v[46]))(?=\s|$)')

cfgs = open(os.path.realpath(os.path.splitext(__file__)[0])+'.yaml').read()
cfg = yaml.load(cfgs)

class Tables:
	v4 = []
	v6 = []
	v4_mark = re.compile('\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}')
	v6_mark = re.compile('[a-f0-9]{1,4}::([a-f0-9]{1,4}|/)') # Far from perfect, but should do
	mark = None
	def append(self, rules, v=None):
		if v: getattr(self, v).append(rules) # Rule was marked during mangling
		elif self.mark: # Rule was hand-marked with proto version
			getattr(self, self.mark).append(rules)
			self.mark = None
		else: # Auto-determine if it's valid for each table
			if not self.v6_mark.search(rules): self.v4.append(rules)
			if not self.v4_mark.search(rules): self.v6.append(rules)
	def fetch(self, v=None):
		str = '\n'.join
		return (str(self.v4), str(self.v6)) if not v else str(getattr(self, v))

core = Tables()


def chainspec(chain):
	# Chain policy specification (like'input-lan/-', 'input/6' or 'input/+')
	if '/' in chain: chain,policy = chain.split('/', 1)
	else: policy = cfg['policy']
	if not policy or policy == '-': policy = 'DROP'
	elif policy.isdigit():
		if policy == '4': policy = ('ACCEPT', 'DROP')
		elif policy == '6': policy = ('DROP', 'ACCEPT')
		else: raise ValueError, 'Incorect policy specification'
	else: policy = 'ACCEPT'

	if '-' in chain: # Like 'input-lan', for chain-global interface specification (useful in svc rules)
		if chain.startswith('input'): rule = '-i'
		elif chain.startswith('output'): rule = '-o'
		else: rule, pre = None, ()
		if rule:
			chain, pre = chain.split('-', 1)
			pre = (rule, pre)
	else: pre = ()

	return chain,policy,pre


for table,chainz in cfg['tablez'].iteritems():
	if table != 'nat': add = core.append
	else: add = lambda x: core.append(x, 'v4')
	add('*'+table) # Table header (like '*filter')

	try: svc = chainz.pop('svc')
	except KeyError: svc = {}

	# Give chains a 'clean', separated from chainspec, names
	for chain in chainz.keys():
		rulez = chainz[chain]
		del chainz[chain]
		chain, policy, pre = chainspec(chain)
		chainz[chain] = policy, [(pre, [rulez] if isinstance(rulez, str) else rulez)] # Only policy from the original chain is used

	if svc: # Extend chains w/ svc rules, if any
		cfgt = re.findall('\n(\s+)'+table+':(.+?)\n((\\1)\S+:.*|$)', cfgs, re.S)[0][1]
		ih = {}
		for name,rulez in svc.iteritems():
			indent = re.findall('^(\s+)'+name+':', cfgt, re.M)
			for i in indent:
				i = i.lstrip('\n')
				try:
					if name not in ih[i]: ih[i].append(name)
				except KeyError: ih[i] = [name]
		indent, ih = sorted(ih.iteritems(), key=lambda x: len(x[1]), reverse=True)[0]
		for name in re.findall('^'+indent+'(\S+):', cfgt, re.M):
			if name not in ih: continue
			try: pre = svc[name].iteritems() # Full specification (dict w/ chain and rules list)
			except AttributeError: pre = [('input', svc[name])] # It's just a list of rules, defaults to input chain
			for chain,rulez in pre:
				chain, policy, pre = chainspec(chain) # Policy here is silently ignored
				rulez = [rulez] if isinstance(rulez, str) else rulez
				chainz[chain][1].append((None, name))
				chainz[chain][1].append((pre, rulez))

	for name,chain in chainz.iteritems():
		name = name.upper()
		policy,ruleset = chain

		# Policy header (like ':INPUT ACCEPT [0:0]')
		policy_gen = lambda policy: '\n:%s %s '%(name, policy.upper()) + '[0:0]\n'
		try:
			v4,v6 = policy
			core.append(policy_gen(v4), 'v4')
			core.append(policy_gen(v6), 'v6')
		except (TypeError, ValueError): add(policy_gen(policy))

		for base,rulez in ruleset:
			if rulez:
				for rule in rulez: # Rule mangling

					# State extension, if requested
					if base == None: # It's a comment
						add('# '+rulez)
						break
					elif cfg['stateful'] and rule and '--state' not in rule and  name == 'INPUT' and '--dport' in rule:
						pre = base + ('--state', 'NEW')
					else: pre = base

					try: # Check rule for magical, inserted by hand, proto marks
						v, core.mark = vmark.findall(rule)[0]
					except (IndexError, TypeError): pass
					else: rule = rule.replace(v, '') # Strip magic

					# Final rules (like '-A INPUT -j DROP')
					if not rule: rule = ('-j', 'DROP')
					elif len(rule) == 1:
						if rule == 'x': rule = ('-j', 'REJECT')
						else: rule = ('-j', 'ACCEPT')
					# Rule actions
					elif rule.endswith(' x'): rule = (rule[:-2], '-j', 'REJECT')
					elif rule.endswith(' -'): rule = (rule[:-2], '-j', 'DROP')
					elif ' -j ' not in rule: rule = (rule, '-j', 'ACCEPT')
					# Full rule, no action mangling is necessary
					else: rule = (rule,)

					rule = ' '.join(('-A', name) + pre + rule) # Rule composition
					for k,v in extents: rule = k.sub(v, rule) # Rule extension (for example, adds '-m ...', where necessary)

					# Protocol extension (clone rule for each proto)
					if rule:
						protos = pex.search(rule)
						if protos:
							rules = []
							for proto in protos.groups()[0].split('/'): rules.append(pex.sub(proto, rule))
							rule = '\n'.join(rules)

					add(rule) # Ta da!

	add('\nCOMMIT\n\n') # Table end marker


# Ignore SIGHUP (in case of SSH break)
import signal
signal.signal(signal.SIGHUP, signal.SIG_IGN) # TODO: add instant-restore as a sighup handler?


from hashlib import md5

def pull_table(v):
	table = Popen(cfg['fs']['bin'][v+'_pull'], stdout=PIPE, stderr=sys.stderr).stdout.read()
	hash = []
	for line in table.splitlines():
		line = line.strip(spaces)
		if not (line.startswith('#') or line.startswith(':')): hash.append(line) # Comments and chains' packet counters
	return table, md5('\n'.join(hash)).hexdigest()


for v in ('v4','v6'):
	# Pull the old table, to check if it's similar to new one (no backup needed in that case)
	old_table,old_hash = pull_table(v)

	# Push new table
	iptables = Popen(cfg['fs']['bin'][v+'_push'], stdin=PIPE, stdout=sys.stdout, stderr=sys.stderr)
	iptables.stdin.write(core.fetch(v))
	iptables.stdin.close()
	iptables.wait() # Wait for process to digest and apply pushed table

	# Pull new table in iptables-save format, to compare against old one
	new_table,new_hash = pull_table(v)

	if old_hash != new_hash:
		# Backup old table in backup.0 slot, rotating the rest of them
		i_slot = None
		for i in sorted([cfg['fs']['bakz'][v]%i for i in xrange(cfg['fs']['bakz']['keep'])], reverse=True):
			if os.path.exists(i) and i_slot: os.rename(i, i_slot)
			i_slot = i
		else: open(i, 'w').write(old_table)
		# Schedule table revert if no commit action will be issued (to ensure that tables are in the sane state)
		if not optz.no_revert:
			at = Popen(
				[cfg['fs']['bakz']['at'], 'now', '+', str(cfg['fs']['bakz']['delay']), 'minutes'],
				stdin=PIPE, stdout=sys.stdout, stderr=sys.stderr
			)
			at.stdin.write('%s < %s\n'%(cfg['fs']['bin'][v+'_push'], i)) # Restore from latest backup
			at.stdin.close()
			at.wait()
